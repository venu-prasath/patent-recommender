{
    "patent_link": "https://patents.google.com/patent/US6104392A/en",
    "patent_id": "US6104392A",
    "title": "Method of displaying an application on a variety of client devices in a client/server network",
    "abstract": "In a client-server architecture, an Adaptive Internet Protocol (AIP) system, comprised of a display engine operating on a server and a protocol engine operating on a server, provides means to support standard graphics based computer applications connected to clients of varying capability via a network of varying bandwidth and latency by automatically varying the type and number of graphic requests and their networking encoding to provide near optimum performance while maintaining the correct visual representation.",
    "inventors": [
        "Andrew Shaw",
        "Karl Richard Burgess",
        "John Marcus Pullan",
        "Peter Charles Cartwright"
    ],
    "assignee": "Sun Microsystems Inc",
    "classifications": [
        "H04L67/303",
        "H04L67/34",
        "H04L67/62",
        "H04L9/40",
        "H04L67/01",
        "H04L69/08",
        "H04L69/18",
        "H04L69/329"
    ],
    "claims": "\n1. In a client server network providing at least one application service for selection by a user via a client device, a method for transmitting to and displaying on the display device of the client device display requests of the requested application service which are not supported by the client device, comprising:\ndownloading from the server and executing on the client device a display engine;\ninitializing a protocol engine with parameters of the client device comprising display operations supported by the client device, the relative cost of each supported operation and a local performance factor and parameters of the connection from the server to the display engine comprising bandwidth and latency;\nexecuting on the server the protocol engine comprising the steps of:\nmaintaining a first queue for retaining pending display requests and a second queue for retaining transmitted display requests of the requested application service for display on the client device; each request having a corresponding relative cost and request time determined by the relative cost and the local performance factor;\nmaintaining a total request time for all requests in both queues and maintaining a total network time for all requests in the second queue;\nwhile the total request time is less than a predetermined first value:\naccepting a new pending request from the application service;\nexecuting the new pending display request to create an image to be displayed on the client device, saving the resulting image to memory and determining for the image its relative cost and its corresponding request time based the local performance factor;\nconverting the new pending display request from the application service into a sequence of converted requests that are supported by the client device, placing the sequence of converted requests in the first queue, determining for each converted display request in the sequence its relative cost and its corresponding request time based on the local performance factor, and incrementing the total request time by the request time of each added request;\nwhile the total network time is less than a predetermined second value:\noptimizing the first queue using a merge optimization when the request times of the pending requests in the first queue exceed a predetermined third value and updating the total request time based on the results of the merge optimization;\nreading a pending request from the first queue and labeling each read request with a first sequence identifier;\nencoding each read display request for transmission to the display engine;\nplacing a copy of the optimized request into the second queue, incrementing the total network time by the request time for the newly added request, and\ntransmitting the encoded display request to the display engine;\nexecuting the display engine comprising the steps of:\nunencoding the received converted display request and displaying it on the client device;\ngenerating a second sequence identifier corresponding to first sequence identifier of the displayed request; and\nperiodically transmitting to the protocol engine the second sequence identifier of the last received display request displayed on the client device; and\nupon receipt of the second sequence identifier, the protocol engine further comprising the steps of:\ndeleting from the second queue the display request whose first sequence identifier is the same as the second sequence identifier and all pending displayed requests in the second queue having first sequence identifiers that are prior to such second sequence identifier; and\ndecrementing from the total request time and from the total network time the request time values of each of the deleted display requests.\n2. The method of claim 1 wherein the relative cost for a request comprises a predetermined fixed basic operation cost and a localized cost per pixel calculated for the client device.\n3. The method of claim 1 wherein the optimization of the first queue further comprises the step of performing a pruning optimization prior to performing the merge optimization.\n4. The method of claim 3 wherein the optimization of the first queue further comprises performing an update scheduling optimization and an attribute scheduling optimization.\n5. The method of claim 1 wherein the optimization of the first queue further comprises performing an update scheduling optimization and an attribute scheduling optimization.\n6. The method of claim 1 wherein the encoding further comprises the steps of\nperforming coordinate compression;\nperforming run length encoding compression;\nserializing the coordinate compressed and run length encoded compressed request into fixed byte ordered strings;\nperforming delta compression; and\nperforming Zlib compression.\n7. The method of claim 6 wherein the encoding further comprises the steps of:\nomitting the steps of run length encoding and delta compression if the bandwidth of the connection to the display engine greater than about 300 Kbytes per second;\napplying the steps of run length encoding and delta compression if the bandwidth of the connection to the display engine is less than about 300 Kbytes per second;\nomitting Zlib compression if the bandwidth of the connection to the display engine is greater than about 300 Kbytes per second;\nsetting the ZLib compression to its lowest and quickest compression level if the bandwidth of the connection to the display engine is between about 100 Kbytes to about 300 Kbytes per second;\nsetting the ZLib compression to a midrange compression level between its highest and lowest compression levels if the bandwidth of the connection to the display engine is between about 3 Kbytes to about 100 Kbytes per second; and\nsetting the ZLib compression to its highest compression level if the bandwidth of the connection to the display engine is less than about 3 Kbytes per second.\n8. The method of claim 7 further comprising:\nperiodically updating the of bandwidth and latency parameters; and\nusing the updated parameters to determine the level of encoding used.\n9. The method of claim 1 further comprising:\nperiodically updating the bandwidth and latency parameters; and\nusing the updated parameters to determine the level of encoding used.\n10. The method of claim 9 further comprising:\nperiodically updating the client device local performance factor and using the updated performance factor to determine the request times of pending requests received after the updating has occurred;\non moving a pending request from the first queue to the second queue adding to the request an time estimate of the time when that request should be removed from the second queue based on the updated local performance factor;\non removing the request from the second queue, maintaining a running average and variance for the percentage error for the estimated time as compared to the actual time that the request was removed, and, if the total of the average error minus half of the variance exceeds a pre-set limit and the time since the last update is more then one minute then immediately repeating the steps of updating the connection parameters and the client device local performance factor parameter.\n11. The method of claim 10 wherein the updated local performance is used to update the request times of the requests in the first and second queues.\n12. The method of claim 1 wherein the predetermined first value is about five seconds, the predetermined second value is about two seconds, and the predetermined third value is about 1/20 of the predetermined first value.\n13. In a client server network providing at least one application service for selection by a user via a client device having a display engine operating thereon, a method for converting, transmitting, and displaying requests of the requested application service that are not supported by the client device, comprising:\ndownloading from the server and executing on the client device a display engine associated with the application service requested by the user;\nloading on a server in the network a protocol engine in communication with the display engine and the requested application service;\nusing the display engine to determine parameters of the client device comprising display operations supported by the client device, the relative cost of each supported operation and a local performance factor and parameters of the connection from the server to the display engine comprising bandwidth and latency;\ntransmitting to and initializing the protocol engine with the client device parameters and the connection parameters;\nexecuting the protocol engine comprising the steps of:\nmaintaining a first queue for retaining pending display requests and a second queue for retaining transmitted display requests of the requested application service for display on the client device; each request having a corresponding relative cost and request time determined by the relative cost and the local performance factor;\nmaintaining a total request time for all requests in both queues and maintaining a total network time for all requests in the second queue;\nwhile the total request time is less than a predetermined first value:\naccepting from the application service a new pending display request to be displayed on the client device;\nexecuting the new pending display request to create an image to be displayed on a portion of a display screen of a client device, saving the resulting image to memory, and determining for the image its relative cost and its corresponding request time based the local performance factor;\nconverting, based on the support display operations of the client device, the new pending display request into a sequence of converted requests that are supported by the client device, placing the sequence of converted requests in the first queue, determining for each converted display request its relative cost and its corresponding request time based on the local performance factor, and incrementing the total request time by the request time of each converted request added to the first queue;\nwhile the total network time is less than a predetermined second value:\noptimizing the first queue using a merge optimization when the request times of the pending requests in the first queue exceed a predetermined third value and updating the total request time based on the results of the merge optimization;\nreading a pending request from the first queue and labeling each read request with a first sequence identifier;\nencoding each read display request for transmission to the display engine;\nplacing a copy of the optimized request into the second queue and incrementing the total network time value for the newly added request; and\ntransmitting the encoded display request to the display engine;\nexecuting the display engine comprising the steps of:\nunencoding the received converted display request and displaying it on the client device;\ngenerating a second sequence identifier corresponding to first sequence identifier of the displayed request; and\nperiodically transmitting to the protocol engine the second sequence identifier of the last received display request displayed on the client device; and\nupon receipt of the second sequence identifier of the last displayed display request, the protocol engine further comprising the steps of:\ndeleting from the second queue the display request whose first sequence identifier is the same as the second sequence identifier and all pending displayed requests in the second queue having identifiers that are prior to such second sequence unique identifier; and\ndecrementing from the total request time and from the total network time the request time values of each of the deleted display requests.\n14. The method of claim 13 wherein the relative cost comprises a predetermined fixed basic operation cost and a localized cost per pixel calculated for the client device.\n15. The method of claim 13 wherein the optimization of the first queue further comprises the step of performing a pruning optimization prior to performing the merge optimization.\n16. The method of claim 15 wherein the optimization of the first queue further comprises performing an update scheduling optimization and an attribute scheduling optimization.\n17. The method of claim 13 wherein the optimization of the first queue further comprises performing an update scheduling optimization and an attribute scheduling optimization.\n18. The method of claim 13 wherein the encoding further comprises the steps of:\nperforming coordinate compression;\nperforming run length encoding compression;\nserializing the coordinate compressed and run length encode compressed request into fixed byte ordered strings;\nperforming delta compression; and\nperforming Zlib compression.\n19. The method of claim 18 wherein the encoding further comprises the steps of:\nomitting the steps of run length encoding and delta compression if the bandwidth of the connection to the display engine greater than about 300 Kbytes per second;\napplying the steps of run length encoding and delta compression if the bandwidth of the connection to the display engine is less than about 300 Kbytes per second;\nomitting Zlib compression if the bandwidth of the connection to the display engine is greater than about 300 Kbytes per second;\nsetting the ZLib compression to its lowest and quickest compression level if the bandwidth of the connection to the display engine is between about 100 Kbytes to about 300 Kbytes per second;\nsetting the ZLib compression to a midrange compression level between its highest and lowest compression levels if the bandwidth of the connection to the display engine is between about 3 Kbytes to about 100 Kbytes per second; and\nsetting the ZLib compression to its highest compression level if the bandwidth of the connection to the display engine is less than about 3 Kbytes per second.\n20. The method of claim 19 further comprising:\nperiodically updating the bandwidth and latency parameters; and\nusing the updated connection parameters to determine the level of encoding used.\n21. The method of claim 13 further comprising:\nperiodically updating the bandwidth and latency parameters; and\nusing the updated parameters to determine the level of encoding used.\n22. The method of claim 21 further comprising:\nperiodically updating the client device local performance factor parameter and using the updated performance factor to update the request times of pending requests received after the updating has occurred;\non moving a pending request from the first queue to the second queue adding to the request an time estimate of the time when that request should be removed from the second queue based on the updated local performance factor;\non removing the request from the second queue, maintaining a running average and variance for the percentage error for the estimated time as compared to the actual time that the request was removed, and, if the total of the average error minus half of the variance exceeds a pre-set limit and the time since the last update is more then 1 minute then immediately repeating the steps of updating the connection parameters and the client device local performance factor parameter.\n23. The method of claim 22 wherein the updated local performance is used to update the request times of the requests in the first and second queues.\n24. The method of claim 13 wherein the predetermined first value is about five seconds, the predetermined second value is about two seconds, and the predetermined third value is about 1/20 of the predetermined first value.\n25. In a client server network providing at least one application service for selection by a user via a client device, a method for transmitting to and displaying on the display device of the client device display requests of the requested application service which are not supported by the client device, comprising:\ndownloading from the server and executing on the client device a display engine associated with the application service requested by the user;\nloading on a server in the network a protocol engine in communication with the display engine and the requested application service;\nproviding to the display a table of display operations expected to be supported by the client device on which the display engine is executing;\nusing the display engine to determine parameters of the client device comprising:\ntesting the operation of each of the expected display operations on the client device and modifying the table to indicate which of the expected display operations was successfully tested;\ndetermining a local performance factor for the client device; and\ndetermining parameters of the connection from the server to the display engine comprising bandwidth and latency;\ntransmitting to and initializing the protocol engine with the client device parameters and the connection parameters as determined by the display engine;\nexecuting the protocol engine comprising the steps of:\nmaintaining a first queue for retaining pending display requests and a second queue for retaining transmitted display requests of the requested application service for display on the client device; each request having a corresponding relative cost and request time determined by the relative cost and the local performance factor;\nmaintaining a total request time for all requests in both queues and maintaining a total network time for all requests in the second queue;\nwhile the total request time is less than a predetermined first value:\naccepting from the application service a new pending display request to be displayed on the client device;\nexecuting the new pending display request to create an image to be displayed on a portion of a display screen of a client device, saving the resulting image to memory, and determining for the image its relative cost and its corresponding request time based the local performance factor;\nconverting, based on the support display operations of the client device, the new pending display request into a sequence of converted requests that are supported by the client device, placing the sequence of converted requests in the first queue, determining for each converted display request its relative cost and its corresponding request time based on the local performance factor, and incrementing the total request time by the request time of each converted request added to the first queue;\nwhile the total network time is less than a predetermined second value:\noptimizing the first queue when the request times of the pending requests in the first queue exceed a predetermined third value by comparing the relative cost of the image to the sum of the relative costs of pending converted display requests in the first queue intended for display on the same portion of the display device of the client device as the image, and, if the relative cost of the image is less than the sum of the relative costs of the compared pending display requests:\nconverting the image into a converted image request and determining its relative cost and its request time based on the local performance factor;\nreplacing in the first queue the compared pending converted display requests with the converted image display request; and\nadjusting the total request time to reflect the addition of the converted image request and removal of the compared pending requests in the first queue;\nreading a pending request from the first queue and labeling each read request with a first sequence identifier;\nencoding each read display request for transmission to the display engine based on the bandwidth of the connection;\nplacing a copy of the optimized request into the second queue and incrementing the total network time value for the newly added request; and\ntransmitting the encoded display request to the display engine;\nusing the display engine to process the received encoded display requests comprising the steps of:\nunencoding the converted display request and displaying it on the client device;\ngenerating a second sequence identifier corresponding to first sequence identifier of the displayed request; and\nperiodically transmitting to the protocol engine the second sequence identifier of the last display request displayed on the client device; and\nupon receipt of the second sequence identifier of the last displayed display request, the protocol engine further comprising the steps of:\ndeleting from the second queue the display request whose first sequence identifier is equal to the second sequence identifier and all pending displayed requests in the second queue having first sequence identifiers that are prior to such second sequence identifier; and\ndecrementing from the total request time value and from the total network time value the time values of each of the deleted display requests.\n26. The method of claim 25 wherein the relative cost comprises a predetermined fixed basic operation cost and a localized per pixel cost based on a performance factor calculated for the client device.\n27. The method of claim 25 wherein the optimization of the first queue further comprises the step of performing a pruning optimization prior to performing the step of optimization.\n28. The method of claim 27 wherein the optimization of the first queue further comprises performing an update scheduling optimization and an attribute scheduling optimization.\n29. The method of claim 25 wherein the optimization of the first queue further comprises performing an update scheduling optimization and an attribute scheduling optimization.\n30. The method of claim 25 wherein the encoding further comprises the steps of\nperforming coordinate compression;\nperforming run length encoding compression;\nserializing the coordinate compressed and run length encode compressed request into fixed byte ordered strings;\nperforming delta compression; and\nperforming Zlib compression.\n31. The method of claim 30 wherein the encoding further comprises the steps of:\nomitting the steps of run length encoding and delta compression if the bandwidth of the connection to the display engine greater than about 300 Kbytes per second;\napplying the steps of run length encoding and delta compression if the bandwidth of the connection to the display engine is less than about 300 Kbytes per second;\nomitting Zlib compression if the bandwidth of the connection to the display engine is greater than about 300 Kbytes per second;\nsetting the ZLib compression to its lowest and quickest compression level if the bandwidth of the connection to the display engine is between about 100 Kbytes to about 300 Kbytes per second;\nsetting the ZLib compression to a midrange compression level between the lowest and highest compression levels if the bandwidth of the connection to the display engine is between about 3 Kbytes to about 100 Kbytes per second; and\nsetting the ZLib compression to its highest compression level if the bandwidth of the connection to the display engine is less than about 3 Kbytes per second.\n32. The method of claim 25 further comprising:\nperiodically updating the client device local performance factor parameter and using the updated performance factor to update the request times of pending requests received after the updating has occurred;\non moving a pending request from the first queue to the second queue adding to the request an time estimate of the time when that request should be removed from the second queue based on the updated local performance factor;\non removing the request from the second queue, maintaining a running average and variance for the percentage error for the estimated time as compared to the actual time that the request was removed, and, if the total of the average error minus half of the variance exceeds a pre-set limit and the time since the last update is more then 1 minute then immediately repeating the steps of updating the connection parameters and the client device local performance factor parameter.\n33. The method of claim 32 wherein the updated local performance is used to update the request times of the requests in the first and second queues.\n34. The method of claim 25 wherein the predetermined first value is about five seconds, the predetermined second value is about two seconds, and the predetermined third value is about 1/20 of the predetermined first value.",
    "status": "Expired - Fee Related",
    "citations_own": [
        "US5740801A",
        "US5754830A",
        "US5796942A",
        "US5999882A"
    ],
    "citations_ftf": [],
    "citedby_own": [
        "US6273821B1",
        "US20020023126A1",
        "US20020038331A1",
        "US20020115477A1",
        "US6446069B1",
        "US20020138597A1",
        "US6470353B1",
        "US6469690B1",
        "US20020169880A1",
        "US20020184536A1",
        "US20020184377A1",
        "US20030114190A1",
        "US20030115038A1",
        "US20030114104A1",
        "US6584404B1",
        "US20030160792A1",
        "US20030160795A1",
        "US6618776B1",
        "US6633314B1",
        "US20030204624A1",
        "US6646656B1",
        "US6654806B2",
        "US6654810B1",
        "US20040006630A1",
        "US6680730B1",
        "US6687750B1",
        "US20040054739A1",
        "EP1310272A3",
        "US20040184664A1",
        "US6842777B1",
        "US6874009B1",
        "US20050088449A1",
        "US6898800B2",
        "US20050132074A1",
        "US20050140692A1",
        "US6915327B1",
        "US6925606B2",
        "US6928461B2",
        "US6941382B1",
        "US20050229108A1",
        "US20050238034A1",
        "US6970903B1",
        "US6973475B2",
        "US6973626B1",
        "US6983421B1",
        "US7003729B1",
        "US7023572B2",
        "US7068381B1",
        "US20060184614A1",
        "US7188240B1",
        "US7188359B2",
        "US7191211B2",
        "US7228503B1",
        "US20070174671A1",
        "US20070239898A1",
        "US7289244B2",
        "US20070255814A1",
        "US20080043643A1",
        "US20080071860A1",
        "CN100378718C",
        "US7356570B1",
        "US20080267069A1",
        "US20090150486A1",
        "US20090157627A1",
        "US20090328080A1",
        "US7743119B2",
        "US20100174677A1",
        "US20110078668A1",
        "US7962603B1",
        "US20110202914A1",
        "US20110225566A1",
        "US8176428B2",
        "US8429111B1",
        "US8516034B1",
        "US8527615B2",
        "US8745173B1",
        "US8766990B1",
        "US8769052B1",
        "US8838749B1",
        "USRE46355E1",
        "US9813514B2",
        "US10026140B2",
        "US20190075131A1"
    ],
    "citedby_ftf": []
}