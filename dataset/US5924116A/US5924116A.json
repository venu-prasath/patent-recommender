{
    "patent_link": "https://patents.google.com/patent/US5924116A/en",
    "patent_id": "US5924116A",
    "title": "Collaborative caching of a requested object by a lower level node as a function of the caching status of the object at a higher level node",
    "abstract": "A method and system of collaboratively caching information to allow improved caching decisions by a lower level or sibling node. In a caching hierarchy, the client and/or servers may factor in the caching status at the higher level in deciding whether to cache an object and which objects are to be replaced. The PICS protocol may be used to pass the caching information of some or all the upper hierarchy down the hierarchy. Furthermore, the caching status information can also be used to direct the object request to the closest higher level proxy which has potentially cached the object, instead of blindly requesting it from the next immediate higher level proxy. A selection policy used to select objects for replacement in the cache may be prioritized not only on the size and the frequency of access of the object, but also on the access time required to get the object if it is not cached. The selection policy may also include a selection weight factor wherein each object is assigned a selection weight based on its replacement cost, the object size and how frequently it is modified. Non-uniform size objects may be classified in ranges of selection weights having geometrically increasing intervals. Multiple LRU stacks may be independently maintained wherein each stack contains objects in a certain range of selection weights. In order to choose candidates for replacement, only the least recently used objects in each group need be considered.",
    "inventors": [
        "Charu Chandra Aggarwal",
        "Peter Kenneth Malkin",
        "Robert Jeffrey Schloss",
        "Philip Shi-lung Yu"
    ],
    "assignee": "International Business Machines Corp",
    "classifications": [],
    "claims": "\n1. In a caching hierarchy including a plurality of nodes, a method of collaboratively caching objects wherein requests for objects are communicated up the hierarchy and objects are communicated down the hierarchy, the method comprising the steps of:\ncommunicating both a caching status of a requested object not cached on a higher level node and the requested object, in response to a request for the requested object; and\ncaching of the requested object by a lower level node as a function of the caching status of the requested object at a higher level node, in response to said communicating step.\n2. The method of claim 1, wherein the hierarchy includes one or more clients and servers and wherein a PICS protocol is used to communicate the caching status of a higher level server, said communicating step further comprising the step of creating a caching label and using a PICS category value to represent the caching status.\n3. The method of claim 2, wherein the requested object, further comprising the steps of:\nsetting a binary value at a highest level in the hierarchy to indicate the caching status;\ncreating and associating a caching label and the caching status with the requested object;\ninterpreting the PICS category value to make a caching decision at the lower level; and\nmodifying the PICS category value to reflect the caching decision at the lower level.\n4. The method of claim 1, including a heterogeneous caching hierarchy wherein said caching step is not performed by all nodes in the hierarchy.\n5. The method of claim 1, wherein a stack is maintained to track the caching status of the most recently referenced objects in the caching hierarchy, further comprising the steps of:\nsetting a cache indicator to indicate the requested object as cached when it is communicated down the hierarchy; wherein the number of entries maintained in the stack is larger than the number of objects cacheable at the node.\n6. The method of claim 5, further comprising the step of a node requesting a missing object as a function of the caching status of the object in the hierarchy.\n7. The method of claim 5, wherein the stack is an LRU stack for tracking the caching status of one or more most recently requested objects in a higher level node, comprising the steps of:\nmaintaining a caching status bit is for each higher level node; wherein the caching status bit identifies whether the requested object is cached at a corresponding node in the hierarchy.\n8. The method of claim 5, further comprising the steps of:\nreceiving a request for an object not in a cache associated with the current node;\nthe current node communicating a request for the object not in the cache to a nearest higher level node associated with the caching status bit having a value of one; and\nthe current node communicating a request for the object not in the cache to a source node if the caching status bit indicates that the object is not cached in the hierarchy.\n9. The method of claim 1, further comprising the steps of:\nsaid communicating step comprising the step of communicating a caching status of the requested object at ancestors of the current node; and\nsaid caching step comprising caching by the lower level node of the requested object as a function of the caching status of the requested object at ancestors of the current node.\n10. The method of claim 1, further comprising the step of:\nmaintaining information on one of an access time and a replacement cost associated with the requested object at higher level nodes; wherein said caching step is a function of one of the access time and the replacement cost.\n11. The method of claim 10, wherein said caching step is a function of an inverse of the access time.\n12. The method of claim 1, wherein said caching step further comprises the steps of:\nmaintaining a priority function on currently cached objects; and\nreplacing one or more of said currently cached objects with the requested object as function of a time since said one or more of said currently cached objects was last accessed and a selection weight.\n13. The method of claim 11, further comprising the step of assigning the selection weight as a function of a how frequently said currently cached objects are modified.\n14. The method of claim 12, further comprising the step of assigning the selection weight as a function of the object size divided by the replacement cost to get the object.\n15. The method of claim 13, further comprising the step of modifying the selection weight modified by a factor on time to obsolescence.\n16. The method of claim 10, wherein the objects are of non-uniform size, comprising steps of:\ndetermining whether to admit the requested object to a cache based on the objects to be replaced, if the requested object is not in the cache; and\nif the requested object not in the cache is determined to be cacheable, replacing an object in the cache with the requested object as a function of a cached object size, a time since last requested, an estimated time to obsolescence (TTO), and the replacement cost.\n17. The method of claim 16, further comprising the steps of: maintaining multiple LRU stacks, each stack corresponding to a stack range of selection weights; and adding information on a newly cached object to a corresponding stack range.\n18. The method of claim 17, further comprising the step of partitioning stack ranges into a predetermined number of ranges according to a geometric progression.\n19. The method of claim 16, further comprising the step of storing object information for each object request in an auxiliary stack; wherein said step of determining whether to admit a requested object to a cache is based on the object information.\n20. The method of claim 19, wherein the object information includes an object identifier, and an object request time.\n21. The method of claim 17, further comprising the step of examining one or more least recently requested object in each LRU stack to determine the replacement candidate.\n22. The method in claim 16, further comprising the step of selecting an object replacement candidate with the minimum value of the product of the object size, the time since last requested, and an adjustment factor according to the TTO, divided by the replacement cost.\n23. The method of claim 22, wherein the adjustment factor is a function of a time since the object was last modified and the time since last requested.\n24. The method of claim 16 wherein the cache includes multiple hierarchical caches.\n25. The method of claim 16, further comprising the step of determining when the object is obsolete; and determining if a refreshed copy of the object will be cached.\n26. The method of claim 16, wherein said step of determining whether to admit the requested object to the cache is based on the time since last requested, and the TTO.\n27. The method of claim 10, further comprising the step of estimating the replacement cost based on the caching status of the hierarchy.\n28. The method of claim 1, wherein the caching hierarchy comprises one or more clients and proxy servers communicatively coupled to the Internet.\n29. In a caching network comprising a plurality of nodes, a method of collaboratively caching objects, the method comprising the steps of:\ncommunicating both a caching status of a requested object not cached on a first node, and the requested object, in response to a request for the requested object; and\ncaching of the requested object by a second node as a function of the caching status of the requested object at the first node, in response to said communicating step.\n30. The method of claim 29, wherein the network includes a caching hierarchy wherein requests for objects are communicated up the hierarchy and objects are communicated down the hierarchy, and wherein the first node is a higher level server and the second node is one of a client and a lower level server, further comprising the steps of:\nsaid communicating step including the step of communicating down the hierarchy both the caching status of the requested object not cached on the higher level node, and the requested object, in response to the request for the requested object; and\ncaching of the requested object by the lower level node as a function of the caching status of the requested object at the higher level server, in response to said communicating step.\n31. The method of claim 29, wherein the nodes are sibling nodes.",
    "status": "Expired - Fee Related",
    "citations_own": [
        "US4755930A",
        "US5008820A",
        "US5063502A",
        "US5222242A",
        "US5446841A",
        "US5511208A",
        "US5530832A",
        "US5682514A",
        "US5737546A",
        "US5781757A"
    ],
    "citations_ftf": [],
    "citedby_own": [
        "US6012098A",
        "US6085234A",
        "GB2345993A",
        "US6098093A",
        "US6112228A",
        "US6122629A",
        "US6128623A",
        "US6131163A",
        "US6167438A",
        "US6189043B1",
        "US6195622B1",
        "WO2001016788A2",
        "US6216154B1",
        "US6247139B1",
        "US6249879B1",
        "US6249844B1",
        "WO2001022195A3",
        "US6289358B1",
        "US20010023451A1",
        "US6301609B1",
        "US6308238B1",
        "US6311216B1",
        "US6314432B1",
        "US6330561B1",
        "US6330605B1",
        "US6330606B1",
        "US20020002602A1",
        "US6338086B1",
        "US6341311B1",
        "US6345292B1",
        "US20020038360A1",
        "US6370620B1",
        "US6377991B1",
        "WO2002035359A2",
        "US20020066044A1",
        "US20020078174A1",
        "US6415368B1",
        "US20020091835A1",
        "US6421713B1",
        "EP1223724A2",
        "US20020099737A1",
        "US20020103974A1",
        "US20020103848A1",
        "US6434608B1",
        "US6434609B1",
        "US6438593B1",
        "US20020131423A1",
        "US6463508B1",
        "US20020147887A1",
        "US6484204B1",
        "US6487539B1",
        "US20020198956A1",
        "US6505241B2",
        "US20030023766A1",
        "US6532492B1",
        "US6546422B1",
        "US6564251B2",
        "US20030110272A1",
        "US20030115421A1",
        "US20030115346A1",
        "US6598036B1",
        "US6601143B1",
        "US6625616B1",
        "US20030188106A1",
        "US20030187917A1",
        "US6671424B1",
        "US20040003032A1",
        "US6675202B1",
        "US20040024808A1",
        "US20040030681A1",
        "US20040054777A1",
        "US20040054748A1",
        "US20040064500A1",
        "US6725330B1",
        "US20040078524A1",
        "US6738865B1",
        "US6742032B1",
        "US20040123301A1",
        "US6757705B1",
        "US6757717B1",
        "US6772225B1",
        "US6772199B1",
        "US20040187160A1",
        "US6801927B1",
        "US20040215717A1",
        "US6832253B1",
        "US6832252B1",
        "US6839809B1",
        "EP1493094A1",
        "US20050015553A1",
        "US6862606B1",
        "US6910052B2",
        "US6910066B1",
        "US20050154791A1",
        "US6954777B1",
        "US20060026229A1",
        "US7054931B1",
        "US7076555B1",
        "US20060160508A1",
        "US20060248195A1",
        "US20060253575A1",
        "US20060282620A1",
        "US20070162702A1",
        "US7313616B1",
        "US20080010414A1",
        "US7320027B1",
        "US7328275B1",
        "US20080086598A1",
        "US20080086599A1",
        "EP2002343A2",
        "US20090024801A1",
        "US7552223B1",
        "US20090228588A1",
        "US20100185745A1",
        "US20110191544A1",
        "US20110196909A1",
        "WO2011140950A1",
        "US20110283018A1",
        "US20120185557A1",
        "US20120233405A1",
        "US20120239823A1",
        "US20130018937A1",
        "US20130132498A1",
        "US8595475B2",
        "US8612550B2",
        "WO2014076504A1",
        "US8918812B2",
        "US20150043592A1",
        "US9195638B2",
        "US9633356B2",
        "US9826033B2",
        "US9948709B2",
        "US10313463B2",
        "US10644984B2",
        "US10686879B2",
        "US10740442B2",
        "US10764391B2"
    ],
    "citedby_ftf": []
}